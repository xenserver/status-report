# spell-checker: disable
"""
Typing stubs for the tarfile module

Generated using mypy's stubgen -p tarfile and manually edited to fix errors.
"""

import io
import types
from _typeshed import Incomplete

# pylint: disable=undefined-variable,unsupported-binary-operation
# pylint: disable=missing-class-docstring,missing-function-docstring

USTAR_FORMAT: int
GNU_FORMAT: int
PAX_FORMAT: int
DEFAULT_FORMAT: int
ENCODING: str

class TarError(Exception): ...
class ExtractError(TarError): ...
class ReadError(TarError): ...
class CompressionError(TarError): ...
class StreamError(TarError): ...
class HeaderError(TarError): ...
class EmptyHeaderError(HeaderError): ...
class TruncatedHeaderError(HeaderError): ...
class EOFHeaderError(HeaderError): ...
class InvalidHeaderError(HeaderError): ...
class SubsequentHeaderError(HeaderError): ...

class _LowLevelFile:
    fd: Incomplete
    def __init__(self, name, mode) -> None: ...
    def close(self) -> None: ...
    def read(self, size): ...
    def write(self, s) -> None: ...

class _Stream:
    name: Incomplete
    mode: Incomplete
    comptype: Incomplete
    fileobj: Incomplete
    bufsize: Incomplete
    buf: bytes
    pos: int
    closed: bool
    zlib: Incomplete
    crc: Incomplete
    exception: Incomplete
    dbuf: bytes
    cmp: Incomplete
    def __init__(self, name, mode, comptype, fileobj, bufsize) -> None: ...
    def __del__(self) -> None: ...
    def write(self, s) -> None: ...
    def close(self) -> None: ...
    def tell(self): ...
    def seek(self, pos: int = 0): ...
    def read(self, size): ...

class _StreamProxy:
    fileobj: Incomplete
    buf: Incomplete
    def __init__(self, fileobj) -> None: ...
    def read(self, size): ...
    def getcomptype(self): ...
    def close(self) -> None: ...

class _FileInFile:
    fileobj: Incomplete
    offset: Incomplete
    size: Incomplete
    position: int
    name: Incomplete
    closed: bool
    map_index: int
    map: Incomplete
    def __init__(self, fileobj, offset, size, blockinfo=None) -> None: ...
    def flush(self) -> None: ...
    def readable(self): ...
    def writable(self): ...
    def seekable(self): ...
    def tell(self): ...
    def seek(self, position, whence=...): ...
    def read(self, size=None): ...
    def readinto(self, b): ...
    def close(self) -> None: ...

class ExFileObject(io.BufferedReader):
    def __init__(self, tarfile, tarinfo) -> None: ...

class FilterError(TarError): ...

class AbsolutePathError(FilterError):
    tarinfo: Incomplete
    def __init__(self, tarinfo) -> None: ...

class OutsideDestinationError(FilterError):
    tarinfo: Incomplete
    def __init__(self, tarinfo, path) -> None: ...

class SpecialFileError(FilterError):
    tarinfo: Incomplete
    def __init__(self, tarinfo) -> None: ...

class AbsoluteLinkError(FilterError):
    tarinfo: Incomplete
    def __init__(self, tarinfo) -> None: ...

class LinkOutsideDestinationError(FilterError):
    tarinfo: Incomplete
    def __init__(self, tarinfo, path) -> None: ...

class LinkFallbackError(FilterError):
    tarinfo: Incomplete
    def __init__(self, tarinfo, path) -> None: ...

class TarInfo:
    name: Incomplete
    mode: int
    uid: int
    gid: int
    size: int
    mtime: int
    chksum: int
    type: Incomplete
    linkname: str
    uname: str
    gname: str
    devmajor: int
    devminor: int
    offset: int
    offset_data: int
    sparse: Incomplete
    pax_headers: Incomplete
    def __init__(self, name: str = "") -> None: ...
    @property
    def path(self): ...
    @path.setter
    def path(self, name) -> None: ...
    @property
    def linkpath(self): ...
    @linkpath.setter
    def linkpath(self, linkname) -> None: ...
    def replace(
        self,
        *,
        name=...,
        mtime=...,
        mode=...,
        linkname=...,
        uid=...,
        gid=...,
        uname=...,
        gname=...,
        deep: bool = True,
        _KEEP=...
    ): ...
    def get_info(self): ...
    def tobuf(self, format=..., encoding=..., errors: str = "surrogateescape"): ...
    def create_ustar_header(self, info, encoding, errors): ...
    def create_gnu_header(self, info, encoding, errors): ...
    def create_pax_header(self, info, encoding): ...
    @classmethod
    def create_pax_global_header(cls, pax_headers): ...
    @classmethod
    def frombuf(cls, buf, encoding, errors): ...
    @classmethod
    def fromtarfile(cls, tarfile): ...
    def isreg(self): ...
    def isfile(self): ...
    def isdir(self): ...
    def issym(self): ...
    def islnk(self): ...
    def ischr(self): ...
    def isblk(self): ...
    def isfifo(self): ...
    def issparse(self): ...
    def isdev(self): ...

class TarFile:
    debug: int
    dereference: bool
    ignore_zeros: bool
    errorlevel: int
    format = DEFAULT_FORMAT
    encoding = ENCODING
    errors: Incomplete
    tarinfo = TarInfo
    fileobject = ExFileObject
    extraction_filter: Incomplete
    mode: Incomplete
    name: Incomplete
    fileobj: Incomplete
    pax_headers: Incomplete
    copybufsize: Incomplete
    closed: bool
    members: Incomplete
    offset: Incomplete
    inodes: Incomplete
    firstmember: Incomplete
    def __init__(
        self,
        name="",
        mode="r",
        fileobj=None,
        format=None,
        tarinfo=TarInfo(),
        dereference=False,
        ignore_zeros=False,
        encoding="utf-8",
        errors="surrogateescape",
        pax_headers=None,
        debug=None,
        errorlevel=None,
        copybufsize=None,
    ) -> None: ...
    @classmethod
    def open(cls, name="", mode: str = "r", fileobj=None, bufsize=..., **kwargs): ...
    @classmethod
    def taropen(cls, name, mode: str = "r", fileobj=None, **kwargs): ...
    @classmethod
    def gzopen(cls, name, mode: str = "r", fileobj=None, compresslevel: int = 9, **kwargs): ...
    @classmethod
    def bz2open(cls, name, mode: str = "r", fileobj=None, compresslevel: int = 9, **kwargs): ...
    @classmethod
    def xzopen(cls, name, mode: str = "r", fileobj=None, preset=None, **kwargs): ...
    OPEN_METH: Incomplete
    def close(self) -> None: ...
    def getmember(self, name): ...
    def getmembers(self): ...
    def getnames(self): ...
    def gettarinfo(self, name=None, arcname=None, fileobj=None): ...
    def list(self, verbose: bool = True, *, members=None) -> None: ...
    def add(self, name, arcname=None, recursive: bool = True, *, filter=None) -> None: ...
    def addfile(self, tarinfo, fileobj=None) -> None: ...
    def extractall(self, path: str = ".", members=None, *, numeric_owner: bool = False, filter=None): ...
    def extract(
        self, member, path: str = "", set_attrs: bool = True, *, numeric_owner: bool = False, filter=None
    ) -> None: ...
    def extractfile(self, member): ...
    def makedir(self, tarinfo, targetpath) -> None: ...
    def makefile(self, tarinfo, targetpath) -> None: ...
    def makeunknown(self, tarinfo, targetpath) -> None: ...
    def makefifo(self, tarinfo, targetpath) -> None: ...
    def makedev(self, tarinfo, targetpath) -> None: ...
    def makelink(self, tarinfo, targetpath): ...
    def makelink_with_filter(self, tarinfo, targetpath, filter_function, extraction_root) -> None: ...
    def chown(self, tarinfo, targetpath, numeric_owner) -> None: ...
    def chmod(self, tarinfo, targetpath) -> None: ...
    def utime(self, tarinfo, targetpath) -> None: ...
    def next(self): ...
    def __iter__(self): ...
    def __enter__(self): ...
    def __exit__(
        self,
        type: type[BaseException] | None,
        value: BaseException | None,
        traceback: types.TracebackType | None,
    ) -> None: ...

def is_tarfile(name): ...

open: Incomplete
